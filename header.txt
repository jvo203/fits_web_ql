3    | pub const __bool_true_false_are_defined : u32 = 1 ; pub const _STDINT_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _ISOC95_SOURCE : u32 = 1 ; pub const _ISOC99_SOURCE : u32 = 1 ; pub const _ISOC11_SOURCE : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const _XOPEN_SOURCE : u32 = 700 ; pub const _XOPEN_SOURCE_EXTENDED : u32 = 1 ; pub const _LARGEFILE64_SOURCE : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_ISOCXX11 : u32 = 1 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const __USE_XOPEN : u32 = 1 ; pub const __USE_XOPEN_EXTENDED : u32 = 1 ; pub const __USE_UNIX98 : u32 = 1 ; pub const _LARGEFILE_SOURCE : u32 = 1 ; pub const __USE_XOPEN2K8XSI : u32 = 1 ; pub const __USE_XOPEN2KXSI : u32 = 1 ; pub const __USE_LARGEFILE : u32 = 1 ; pub const __USE_LARGEFILE64 : u32 = 1 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_GNU : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 1 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_ISO_10646__ : u32 = 201706 ; pub const __STDC_NO_THREADS__ : u32 = 1 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 27 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __glibc_c99_flexarr_available : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const __HAVE_GENERIC_SELECTION : u32 = 0 ; pub const __GLIBC_USE_LIB_EXT2 : u32 = 1 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 1 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 1 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 1 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const _BITS_STDINT_INTN_H : u32 = 1 ; pub const _BITS_STDINT_UINTN_H : u32 = 1 ; pub const INT8_MIN : i32 = -128 ; pub const INT16_MIN : i32 = -32768 ; pub const INT32_MIN : i32 = -2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = -128 ; pub const INT_LEAST16_MIN : i32 = -32768 ; pub const INT_LEAST32_MIN : i32 = -2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = -128 ; pub const INT_FAST16_MIN : i64 = -9223372036854775808 ; pub const INT_FAST32_MIN : i64 = -9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = -1 ; pub const UINT_FAST32_MAX : i32 = -1 ; pub const INTPTR_MIN : i64 = -9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = -1 ; pub const PTRDIFF_MIN : i64 = -9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = -2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = -1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const INT8_WIDTH : u32 = 8 ; pub const UINT8_WIDTH : u32 = 8 ; pub const INT16_WIDTH : u32 = 16 ; pub const UINT16_WIDTH : u32 = 16 ; pub const INT32_WIDTH : u32 = 32 ; pub const UINT32_WIDTH : u32 = 32 ; pub const INT64_WIDTH : u32 = 64 ; pub const UINT64_WIDTH : u32 = 64 ; pub const INT_LEAST8_WIDTH : u32 = 8 ; pub const UINT_LEAST8_WIDTH : u32 = 8 ; pub const INT_LEAST16_WIDTH : u32 = 16 ; pub const UINT_LEAST16_WIDTH : u32 = 16 ; pub const INT_LEAST32_WIDTH : u32 = 32 ; pub const UINT_LEAST32_WIDTH : u32 = 32 ; pub const INT_LEAST64_WIDTH : u32 = 64 ; pub const UINT_LEAST64_WIDTH : u32 = 64 ; pub const INT_FAST8_WIDTH : u32 = 8 ; pub const UINT_FAST8_WIDTH : u32 = 8 ; pub const INT_FAST16_WIDTH : u32 = 64 ; pub const UINT_FAST16_WIDTH : u32 = 64 ; pub const INT_FAST32_WIDTH : u32 = 64 ; pub const UINT_FAST32_WIDTH : u32 = 64 ; pub const INT_FAST64_WIDTH : u32 = 64 ; pub const UINT_FAST64_WIDTH : u32 = 64 ; pub const INTPTR_WIDTH : u32 = 64 ; pub const UINTPTR_WIDTH : u32 = 64 ; pub const INTMAX_WIDTH : u32 = 64 ; pub const UINTMAX_WIDTH : u32 = 64 ; pub const PTRDIFF_WIDTH : u32 = 64 ; pub const SIG_ATOMIC_WIDTH : u32 = 32 ; pub const SIZE_WIDTH : u32 = 64 ; pub const WCHAR_WIDTH : u32 = 32 ; pub const WINT_WIDTH : u32 = 32 ; pub const INT64_F : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const CPU_X86 : u32 = 1 ; pub const LIBYUV_FALSE : u32 = 0 ; pub const LIBYUV_TRUE : u32 = 1 ; pub const _STDIO_H : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const __FILE_defined : u32 = 1 ; pub const _BITS_LIBIO_H : u32 = 1 ; pub const _BITS_G_CONFIG_H : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _G_HAVE_MMAP : u32 = 1 ; pub const _G_HAVE_MREMAP : u32 = 1 ; pub const _G_IO_IO_FILE_VERSION : u32 = 131073 ; pub const _G_BUFSIZ : u32 = 8192 ; pub const _IO_BUFSIZ : u32 = 8192 ; pub const __GNUC_VA_LIST : u32 = 1 ; pub const _IO_UNIFIED_JUMPTABLES : u32 = 1 ; pub const EOF : i32 = -1 ; pub const _IOS_INPUT : u32 = 1 ; pub const _IOS_OUTPUT : u32 = 2 ; pub const _IOS_ATEND : u32 = 4 ; pub const _IOS_APPEND : u32 = 8 ; pub const _IOS_TRUNC : u32 = 16 ; pub const _IOS_NOCREATE : u32 = 32 ; pub const _IOS_NOREPLACE : u32 = 64 ; pub const _IOS_BIN : u32 = 128 ; pub const _IO_MAGIC : u32 = 4222418944 ; pub const _OLD_STDIO_MAGIC : u32 = 4206624768 ; pub const _IO_MAGIC_MASK : u32 = 4294901760 ; pub const _IO_USER_BUF : u32 = 1 ; pub const _IO_UNBUFFERED : u32 = 2 ; pub const _IO_NO_READS : u32 = 4 ; pub const _IO_NO_WRITES : u32 = 8 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_DELETE_DONT_CLOSE : u32 = 64 ; pub const _IO_LINKED : u32 = 128 ; pub const _IO_IN_BACKUP : u32 = 256 ; pub const _IO_LINE_BUF : u32 = 512 ; pub const _IO_TIED_PUT_GET : u32 = 1024 ; pub const _IO_CURRENTLY_PUTTING : u32 = 2048 ; pub const _IO_IS_APPENDING : u32 = 4096 ; pub const _IO_IS_FILEBUF : u32 = 8192 ; pub const _IO_BAD_SEEN : u32 = 16384 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const _IO_FLAGS2_MMAP : u32 = 1 ; pub const _IO_FLAGS2_NOTCANCEL : u32 = 2 ; pub const _IO_FLAGS2_USER_WBUF : u32 = 8 ; pub const _IO_SKIPWS : u32 = 1 ; pub const _IO_LEFT : u32 = 2 ; pub const _IO_RIGHT : u32 = 4 ; pub const _IO_INTERNAL : u32 = 8 ; pub const _IO_DEC : u32 = 16 ; pub const _IO_OCT : u32 = 32 ; pub const _IO_HEX : u32 = 64 ; pub const _IO_SHOWBASE : u32 = 128 ; pub const _IO_SHOWPOINT : u32 = 256 ; pub const _IO_UPPERCASE : u32 = 512 ; pub const _IO_SHOWPOS : u32 = 1024 ; pub const _IO_SCIENTIFIC : u32 = 2048 ; pub const _IO_FIXED : u32 = 4096 ; pub const _IO_UNITBUF : u32 = 8192 ; pub const _IO_STDIO : u32 = 16384 ; pub const _IO_DONT_CLOSE : u32 = 32768 ; pub const _IO_BOOLALPHA : u32 = 65536 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const SEEK_DATA : u32 = 3 ; pub const SEEK_HOLE : u32 = 4 ; pub const P_tmpdir : & 'static [ u8 ; 5usize ] = b"/tmp\0" ; pub const _BITS_STDIO_LIM_H : u32 = 1 ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const L_cuserid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub const X265_BUILD : u32 = 160 ; pub const X265_LOOKAHEAD_MAX : u32 = 250 ; pub const X265_CPU_MMX : u32 = 1 ; pub const X265_CPU_MMX2 : u32 = 2 ; pub const X265_CPU_MMXEXT : u32 = 2 ; pub const X265_CPU_SSE : u32 = 4 ; pub const X265_CPU_SSE2 : u32 = 8 ; pub const X265_CPU_LZCNT : u32 = 16 ; pub const X265_CPU_SSE3 : u32 = 32 ; pub const X265_CPU_SSSE3 : u32 = 64 ; pub const X265_CPU_SSE4 : u32 = 128 ; pub const X265_CPU_SSE42 : u32 = 256 ; pub const X265_CPU_AVX : u32 = 512 ; pub const X265_CPU_XOP : u32 = 1024 ; pub const X265_CPU_FMA4 : u32 = 2048 ; pub const X265_CPU_FMA3 : u32 = 4096 ; pub const X265_CPU_BMI1 : u32 = 8192 ; pub const X265_CPU_BMI2 : u32 = 16384 ; pub const X265_CPU_AVX2 : u32 = 32768 ; pub const X265_CPU_AVX512 : u32 = 65536 ; pub const X265_CPU_CACHELINE_32 : u32 = 131072 ; pub const X265_CPU_CACHELINE_64 : u32 = 262144 ; pub const X265_CPU_SSE2_IS_SLOW : u32 = 524288 ; pub const X265_CPU_SSE2_IS_FAST : u32 = 1048576 ; pub const X265_CPU_SLOW_SHUFFLE : u32 = 2097152 ; pub const X265_CPU_STACK_MOD4 : u32 = 4194304 ; pub const X265_CPU_SLOW_ATOM : u32 = 8388608 ; pub const X265_CPU_SLOW_PSHUFB : u32 = 16777216 ; pub const X265_CPU_SLOW_PALIGNR : u32 = 33554432 ; pub const X265_CPU_ARMV6 : u32 = 1 ; pub const X265_CPU_NEON : u32 = 2 ; pub const X265_CPU_FAST_NEON_MRC : u32 = 4 ; pub const X265_CPU_ALTIVEC : u32 = 1 ; pub const X265_MAX_SUBPEL_LEVEL : u32 = 7 ; pub const X265_LOG_NONE : i32 = -1 ; pub const X265_LOG_ERROR : u32 = 0 ; pub const X265_LOG_WARNING : u32 = 1 ; pub const X265_LOG_INFO : u32 = 2 ; pub const X265_LOG_DEBUG : u32 = 3 ; pub const X265_LOG_FULL : u32 = 4 ; pub const X265_B_ADAPT_NONE : u32 = 0 ; pub const X265_B_ADAPT_FAST : u32 = 1 ; pub const X265_B_ADAPT_TRELLIS : u32 = 2 ; pub const X265_REF_LIMIT_DEPTH : u32 = 1 ; pub const X265_REF_LIMIT_CU : u32 = 2 ; pub const X265_TU_LIMIT_BFS : u32 = 1 ; pub const X265_TU_LIMIT_DFS : u32 = 2 ; pub const X265_TU_LIMIT_NEIGH : u32 = 4 ; pub const X265_BFRAME_MAX : u32 = 16 ; pub const X265_MAX_FRAME_THREADS : u32 = 16 ; pub const X265_TYPE_AUTO : u32 = 0 ; pub const X265_TYPE_IDR : u32 = 1 ; pub const X265_TYPE_I : u32 = 2 ; pub const X265_TYPE_P : u32 = 3 ; pub const X265_TYPE_BREF : u32 = 4 ; pub const X265_TYPE_B : u32 = 5 ; pub const X265_QP_AUTO : u32 = 0 ; pub const X265_AQ_NONE : u32 = 0 ; pub const X265_AQ_VARIANCE : u32 = 1 ; pub const X265_AQ_AUTO_VARIANCE : u32 = 2 ; pub const X265_AQ_AUTO_VARIANCE_BIASED : u32 = 3 ; pub const x265_ADAPT_RD_STRENGTH : u32 = 4 ; pub const X265_REFINE_INTER_LEVELS : u32 = 3 ; pub const X265_CSP_I400 : u32 = 0 ; pub const X265_CSP_I420 : u32 = 1 ; pub const X265_CSP_I422 : u32 = 2 ; pub const X265_CSP_I444 : u32 = 3 ; pub const X265_CSP_COUNT : u32 = 4 ; pub const X265_CSP_NV12 : u32 = 4 ; pub const X265_CSP_NV16 : u32 = 5 ; pub const X265_CSP_BGR : u32 = 6 ; pub const X265_CSP_BGRA : u32 = 7 ; pub const X265_CSP_RGB : u32 = 8 ; pub const X265_CSP_MAX : u32 = 9 ; pub const X265_EXTENDED_SAR : u32 = 255 ; pub const X265_ANALYSIS_OFF : u32 = 0 ; pub const X265_ANALYSIS_SAVE : u32 = 1 ; pub const X265_ANALYSIS_LOAD : u32 = 2 ; pub const X265_PARAM_BAD_NAME : i32 = -1 ; pub const X265_PARAM_BAD_VALUE : i32 = -2 ; pub const X265_MAJOR_VERSION : u32 = 1 ; pub const X265_API_QUERY_ERR_NONE : u32 = 0 ; pub const X265_API_QUERY_ERR_VER_REFUSED : u32 = 1 ; pub const X265_API_QUERY_ERR_LIB_NOT_FOUND : u32 = 2 ; pub const X265_API_QUERY_ERR_FUNC_NOT_FOUND : u32 = 3 ; pub const X265_API_QUERY_ERR_WRONG_BITDEPTH : u32 = 4 ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; extern "C" { # [ link_name = "\u{1}bilinear_resize" ] pub fn ispc_bilinear_resize ( src : * mut i8 , src_len : i32 , dst : * mut i8 , dst_len : i32 , src_width : i32 , src_height : i32 , dst_width : u32 , dst_height : u32 , scale_factor : f32 , filter_width : f32 ) ; } extern "C" { # [ link_name = "\u{1}calculate_radial_spectrumF16" ] pub fn ispc_calculate_radial_spectrumF16 ( cubeData : * mut i16 , bzero : f32 , bscale : f32 , datamin : f32 , datamax : f32 , width : u32 , x1 : i32 , x2 : i32 , y1 : i32 , y2 : i32 , cx : i32 , cy : i32 , r2 : i32 , average : bool , cdelt3 : f32 ) -> f32 ; } extern "C" { # [ link_name = "\u{1}calculate_square_spectrumF16" ] pub fn ispc_calculate_square_spectrumF16 ( cubeData : * mut i16 , bzero : f32 , bscale : f32 , datamin : f32 , datamax : f32 , width : u32 , x1 : i32 , x2 : i32 , y1 : i32 , y2 : i32 , average : bool , cdelt3 : f32 ) -> f32 ; } extern "C" { # [ link_name = "\u{1}data_to_luminance_f16_legacy" ] pub fn ispc_data_to_luminance_f16_legacy ( cubeData : * mut i16 , mask : * mut u8 , bzero : f32 , bscale : f32 , dmin : f32 , dmax : f32 , lmin : f32 , lmax : f32 , pixels : * mut u8 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}data_to_luminance_f16_linear" ] pub fn ispc_data_to_luminance_f16_linear ( cubeData : * mut i16 , mask : * mut u8 , bzero : f32 , bscale : f32 , black : f32 , slope : f32 , pixels : * mut u8 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}data_to_luminance_f16_logistic" ] pub fn ispc_data_to_luminance_f16_logistic ( cubeData : * mut i16 , mask : * mut u8 , bzero : f32 , bscale : f32 , median : f32 , sensitivity : f32 , pixels : * mut u8 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}data_to_luminance_f16_ratio" ] pub fn ispc_data_to_luminance_f16_ratio ( cubeData : * mut i16 , mask : * mut u8 , bzero : f32 , bscale : f32 , black : f32 , sensitivity : f32 , pixels : * mut u8 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}data_to_luminance_f16_square" ] pub fn ispc_data_to_luminance_f16_square ( cubeData : * mut i16 , mask : * mut u8 , bzero : f32 , bscale : f32 , black : f32 , sensitivity : f32 , pixels : * mut u8 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}join_pixels_masks" ] pub fn ispc_join_pixels_masks ( pixels : * mut f32 , pixels_tid : * mut f32 , mask : * mut u8 , mask_tid : * mut u8 , cdelt3 : f32 , total_size : u32 ) ; } extern "C" { # [ link_name = "\u{1}make_image_spectrumF16_minmax" ] pub fn ispc_make_image_spectrumF16_minmax ( fitsData : * mut i16 , bzero : f32 , bscale : f32 , datamin : f32 , datamax : f32 , cdelt3 : f32 , pixels : * mut f32 , mask : * mut u8 , total_size : u32 , references : * mut f32 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce2 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce2 ) ) ) ; } pub type uint64 = :: std :: os :: raw :: c_ulong ; pub type int64 = :: std :: os :: raw :: c_long ; pub type uint32 = :: std :: os :: raw :: c_uint ; pub type int32 = :: std :: os :: raw :: c_int ; pub type uint16 = :: std :: os :: raw :: c_ushort ; pub type int16 = :: std :: os :: raw :: c_short ; pub type uint8 = :: std :: os :: raw :: c_uchar ; pub type int8 = :: std :: os :: raw :: c_schar ; pub const libyuv_FilterMode_kFilterNone : libyuv_FilterMode = 0 ; pub const libyuv_FilterMode_kFilterLinear : libyuv_FilterMode = 1 ; pub const libyuv_FilterMode_kFilterBilinear : libyuv_FilterMode = 2 ; pub const libyuv_FilterMode_kFilterBox : libyuv_FilterMode = 3 ; pub type libyuv_FilterMode = u32 ; pub use self :: libyuv_FilterMode as libyuv_FilterModeEnum ; extern "C" { # [ link_name = "\u{1}ScalePlane" ] pub fn libyuv_ScalePlane ( src : * const uint8 , src_stride : :: std :: os :: raw :: c_int , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst : * mut uint8 , dst_stride : :: std :: os :: raw :: c_int , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , filtering : libyuv_FilterMode ) ; } extern "C" { # [ link_name = "\u{1}ScalePlane_16" ] pub fn libyuv_ScalePlane_16 ( src : * const uint16 , src_stride : :: std :: os :: raw :: c_int , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst : * mut uint16 , dst_stride : :: std :: os :: raw :: c_int , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , filtering : libyuv_FilterMode ) ; } extern "C" { # [ link_name = "\u{1}I420Scale" ] pub fn libyuv_I420Scale ( src_y : * const uint8 , src_stride_y : :: std :: os :: raw :: c_int , src_u : * const uint8 , src_stride_u : :: std :: os :: raw :: c_int , src_v : * const uint8 , src_stride_v : :: std :: os :: raw :: c_int , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst_y : * mut uint8 , dst_stride_y : :: std :: os :: raw :: c_int , dst_u : * mut uint8 , dst_stride_u : :: std :: os :: raw :: c_int , dst_v : * mut uint8 , dst_stride_v : :: std :: os :: raw :: c_int , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , filtering : libyuv_FilterMode ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}I420Scale_16" ] pub fn libyuv_I420Scale_16 ( src_y : * const uint16 , src_stride_y : :: std :: os :: raw :: c_int , src_u : * const uint16 , src_stride_u : :: std :: os :: raw :: c_int , src_v : * const uint16 , src_stride_v : :: std :: os :: raw :: c_int , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst_y : * mut uint16 , dst_stride_y : :: std :: os :: raw :: c_int , dst_u : * mut uint16 , dst_stride_u : :: std :: os :: raw :: c_int , dst_v : * mut uint16 , dst_stride_v : :: std :: os :: raw :: c_int , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , filtering : libyuv_FilterMode ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}Scale" ] pub fn libyuv_Scale ( src_y : * const uint8 , src_u : * const uint8 , src_v : * const uint8 , src_stride_y : :: std :: os :: raw :: c_int , src_stride_u : :: std :: os :: raw :: c_int , src_stride_v : :: std :: os :: raw :: c_int , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst_y : * mut uint8 , dst_u : * mut uint8 , dst_v : * mut uint8 , dst_stride_y : :: std :: os :: raw :: c_int , dst_stride_u : :: std :: os :: raw :: c_int , dst_stride_v : :: std :: os :: raw :: c_int , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , interpolate : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}ScaleOffset" ] pub fn libyuv_ScaleOffset ( src_i420 : * const uint8 , src_width : :: std :: os :: raw :: c_int , src_height : :: std :: os :: raw :: c_int , dst_i420 : * mut uint8 , dst_width : :: std :: os :: raw :: c_int , dst_height : :: std :: os :: raw :: c_int , dst_yoffset : :: std :: os :: raw :: c_int , interpolate : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}SetUseReferenceImpl" ] pub fn libyuv_SetUseReferenceImpl ( use_ : :: std :: os :: raw :: c_int ) ; } pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ) ) ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _sbuf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _pos as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ) ) ; } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_end as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_base as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_base as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_end as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_base as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_end as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_base as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_backup_base as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_end as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _markers as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _chain as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _fileno as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags2 as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _old_offset as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _cur_column as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _vtable_offset as * const _ as usize } , 130usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _shortbuf as * const _ as usize } , 131usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _lock as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad1 as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad2 as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad3 as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad4 as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad5 as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _mode as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _unused2 as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdin_" ] pub static mut _IO_2_1_stdin_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdout_" ] pub static mut _IO_2_1_stdout_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stderr_" ] pub static mut _IO_2_1_stderr_ : _IO_FILE_plus ; } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; pub type cookie_read_function_t = __io_read_fn ; pub type cookie_write_function_t = __io_write_fn ; pub type cookie_seek_function_t = __io_seek_fn ; pub type cookie_close_function_t = __io_close_fn ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_cookie_io_functions_t { pub read : __io_read_fn , pub write : __io_write_fn , pub seek : __io_seek_fn , pub close : __io_close_fn , } # [ test ] fn bindgen_test_layout__IO_cookie_io_functions_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_cookie_io_functions_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _IO_cookie_io_functions_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_cookie_io_functions_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_cookie_io_functions_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_cookie_io_functions_t > ( ) ) ) . read as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( read ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_cookie_io_functions_t > ( ) ) ) . write as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( write ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_cookie_io_functions_t > ( ) ) ) . seek as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_cookie_io_functions_t > ( ) ) ) . close as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( close ) ) ) ; } pub type cookie_io_functions_t = _IO_cookie_io_functions_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_cookie_file { _unused : [ u8 ; 0 ] , } extern "C" { pub fn _IO_cookie_init ( __cfile : * mut _IO_cookie_file , __read_write : :: std :: os :: raw :: c_int , __cookie : * mut :: std :: os :: raw :: c_void , __fns : _IO_cookie_io_functions_t ) ; } extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type off64_t = __off64_t ; pub type fpos_t = _G_fpos_t ; pub type fpos64_t = _G_fpos64_t ; extern "C" { # [ link_name = "\u{1}stdin" ] pub static mut stdin : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stdout" ] pub static mut stdout : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stderr" ] pub static mut stderr : * mut _IO_FILE ; } extern "C" { pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpfile64 ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fcloseall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fopen64 ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen64 ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fopencookie ( __magic_cookie : * mut :: std :: os :: raw :: c_void , __modes : * const :: std :: os :: raw :: c_char , __io_funcs : _IO_cookie_io_functions_t ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vasprintf ( __ptr : * mut * mut :: std :: os :: raw :: c_char , __f : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __asprintf ( __ptr : * mut * mut :: std :: os :: raw :: c_char , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asprintf ( __ptr : * mut * mut :: std :: os :: raw :: c_char , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn gets ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fgets_unlocked ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fputs_unlocked ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fseeko64 ( __stream : * mut FILE , __off : __off64_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello64 ( __stream : * mut FILE ) -> __off64_t ; } extern "C" { pub fn fgetpos64 ( __stream : * mut FILE , __pos : * mut fpos64_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos64 ( __stream : * mut FILE , __pos : * const fpos64_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}sys_nerr" ] pub static mut sys_nerr : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}sys_errlist" ] pub static mut sys_errlist : [ * const :: std :: os :: raw :: c_char ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_sys_nerr" ] pub static mut _sys_nerr : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_sys_errlist" ] pub static mut _sys_errlist : [ * const :: std :: os :: raw :: c_char ; 0usize ] ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn cuserid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct obstack { _unused : [ u8 ; 0 ] , } extern "C" { pub fn obstack_printf ( __obstack : * mut obstack , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn obstack_vprintf ( __obstack : * mut obstack , __format : * const :: std :: os :: raw :: c_char , __args : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_encoder { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_picyuv { _unused : [ u8 ; 0 ] , } pub const NalUnitType_NAL_UNIT_CODED_SLICE_TRAIL_N : NalUnitType = 0 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_TRAIL_R : NalUnitType = 1 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_TSA_N : NalUnitType = 2 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_TLA_R : NalUnitType = 3 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_STSA_N : NalUnitType = 4 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_STSA_R : NalUnitType = 5 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_RADL_N : NalUnitType = 6 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_RADL_R : NalUnitType = 7 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_RASL_N : NalUnitType = 8 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_RASL_R : NalUnitType = 9 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_BLA_W_LP : NalUnitType = 16 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_BLA_W_RADL : NalUnitType = 17 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_BLA_N_LP : NalUnitType = 18 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_IDR_W_RADL : NalUnitType = 19 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_IDR_N_LP : NalUnitType = 20 ; pub const NalUnitType_NAL_UNIT_CODED_SLICE_CRA : NalUnitType = 21 ; pub const NalUnitType_NAL_UNIT_VPS : NalUnitType = 32 ; pub const NalUnitType_NAL_UNIT_SPS : NalUnitType = 33 ; pub const NalUnitType_NAL_UNIT_PPS : NalUnitType = 34 ; pub const NalUnitType_NAL_UNIT_ACCESS_UNIT_DELIMITER : NalUnitType = 35 ; pub const NalUnitType_NAL_UNIT_EOS : NalUnitType = 36 ; pub const NalUnitType_NAL_UNIT_EOB : NalUnitType = 37 ; pub const NalUnitType_NAL_UNIT_FILLER_DATA : NalUnitType = 38 ; pub const NalUnitType_NAL_UNIT_PREFIX_SEI : NalUnitType = 39 ; pub const NalUnitType_NAL_UNIT_SUFFIX_SEI : NalUnitType = 40 ; pub const NalUnitType_NAL_UNIT_INVALID : NalUnitType = 64 ; pub type NalUnitType = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_nal { pub type_ : u32 , pub sizeBytes : u32 , pub payload : * mut u8 , } # [ test ] fn bindgen_test_layout_x265_nal ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_nal > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( x265_nal ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_nal > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_nal ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_nal > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_nal ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_nal > ( ) ) ) . sizeBytes as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_nal ) , "::" , stringify ! ( sizeBytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_nal > ( ) ) ) . payload as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_nal ) , "::" , stringify ! ( payload ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct x265_lookahead_data { pub plannedSatd : [ i64 ; 251usize ] , pub vbvCost : * mut u32 , pub intraVbvCost : * mut u32 , pub satdForVbv : * mut u32 , pub intraSatdForVbv : * mut u32 , pub keyframe : :: std :: os :: raw :: c_int , pub lastMiniGopBFrame : :: std :: os :: raw :: c_int , pub plannedType : [ :: std :: os :: raw :: c_int ; 251usize ] , pub dts : i64 , pub reorderedPts : i64 , } # [ test ] fn bindgen_test_layout_x265_lookahead_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_lookahead_data > ( ) , 3072usize , concat ! ( "Size of: " , stringify ! ( x265_lookahead_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_lookahead_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_lookahead_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . plannedSatd as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( plannedSatd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . vbvCost as * const _ as usize } , 2008usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( vbvCost ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . intraVbvCost as * const _ as usize } , 2016usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( intraVbvCost ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . satdForVbv as * const _ as usize } , 2024usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( satdForVbv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . intraSatdForVbv as * const _ as usize } , 2032usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( intraSatdForVbv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . keyframe as * const _ as usize } , 2040usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( keyframe ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . lastMiniGopBFrame as * const _ as usize } , 2044usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( lastMiniGopBFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . plannedType as * const _ as usize } , 2048usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( plannedType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . dts as * const _ as usize } , 3056usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_lookahead_data > ( ) ) ) . reorderedPts as * const _ as usize } , 3064usize , concat ! ( "Offset of field: " , stringify ! ( x265_lookahead_data ) , "::" , stringify ! ( reorderedPts ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_analysis_validate { pub maxNumReferences : :: std :: os :: raw :: c_int , pub analysisReuseLevel : :: std :: os :: raw :: c_int , pub scaleFactor : :: std :: os :: raw :: c_int , pub keyframeMax : :: std :: os :: raw :: c_int , pub keyframeMin : :: std :: os :: raw :: c_int , pub openGOP : :: std :: os :: raw :: c_int , pub bframes : :: std :: os :: raw :: c_int , pub bPyramid : :: std :: os :: raw :: c_int , pub maxCUSize : :: std :: os :: raw :: c_int , pub minCUSize : :: std :: os :: raw :: c_int , pub radl : :: std :: os :: raw :: c_int , pub lookaheadDepth : :: std :: os :: raw :: c_int , pub gopLookahead : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_x265_analysis_validate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_analysis_validate > ( ) , 52usize , concat ! ( "Size of: " , stringify ! ( x265_analysis_validate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_analysis_validate > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( x265_analysis_validate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . maxNumReferences as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( maxNumReferences ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . analysisReuseLevel as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( analysisReuseLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . scaleFactor as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( scaleFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . keyframeMax as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( keyframeMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . keyframeMin as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( keyframeMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . openGOP as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( openGOP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . bframes as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( bframes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . bPyramid as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( bPyramid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . maxCUSize as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( maxCUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . minCUSize as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( minCUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . radl as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( radl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . lookaheadDepth as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( lookaheadDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_validate > ( ) ) ) . gopLookahead as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_validate ) , "::" , stringify ! ( gopLookahead ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct x265_analysis_data { pub satdCost : i64 , pub frameRecordSize : u32 , pub poc : u32 , pub sliceType : u32 , pub numCUsInFrame : u32 , pub numPartitions : u32 , pub depthBytes : u32 , pub bScenecut : :: std :: os :: raw :: c_int , pub wt : * mut :: std :: os :: raw :: c_void , pub interData : * mut :: std :: os :: raw :: c_void , pub intraData : * mut :: std :: os :: raw :: c_void , pub numCuInHeight : u32 , pub lookahead : x265_lookahead_data , pub modeFlag : [ * mut u8 ; 2usize ] , pub saveParam : x265_analysis_validate , } # [ test ] fn bindgen_test_layout_x265_analysis_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_analysis_data > ( ) , 3216usize , concat ! ( "Size of: " , stringify ! ( x265_analysis_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_analysis_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_analysis_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . satdCost as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( satdCost ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . frameRecordSize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( frameRecordSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . poc as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( poc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . sliceType as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( sliceType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . numCUsInFrame as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( numCUsInFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . numPartitions as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( numPartitions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . depthBytes as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( depthBytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . bScenecut as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( bScenecut ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . wt as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( wt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . interData as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( interData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . intraData as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( intraData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . numCuInHeight as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( numCuInHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . lookahead as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( lookahead ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . modeFlag as * const _ as usize } , 3144usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( modeFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_data > ( ) ) ) . saveParam as * const _ as usize } , 3160usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_data ) , "::" , stringify ! ( saveParam ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_cu_stats { pub percentSkipCu : [ f64 ; 4usize ] , pub percentMergeCu : [ f64 ; 4usize ] , pub percentIntraDistribution : [ [ f64 ; 3usize ] ; 4usize ] , pub percentInterDistribution : [ [ f64 ; 3usize ] ; 4usize ] , pub percentIntraNxN : f64 , } # [ test ] fn bindgen_test_layout_x265_cu_stats ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_cu_stats > ( ) , 264usize , concat ! ( "Size of: " , stringify ! ( x265_cu_stats ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_cu_stats > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_cu_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cu_stats > ( ) ) ) . percentSkipCu as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_cu_stats ) , "::" , stringify ! ( percentSkipCu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cu_stats > ( ) ) ) . percentMergeCu as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_cu_stats ) , "::" , stringify ! ( percentMergeCu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cu_stats > ( ) ) ) . percentIntraDistribution as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_cu_stats ) , "::" , stringify ! ( percentIntraDistribution ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cu_stats > ( ) ) ) . percentInterDistribution as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( x265_cu_stats ) , "::" , stringify ! ( percentInterDistribution ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cu_stats > ( ) ) ) . percentIntraNxN as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( x265_cu_stats ) , "::" , stringify ! ( percentIntraNxN ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_pu_stats { pub percentSkipPu : [ f64 ; 4usize ] , pub percentIntraPu : [ f64 ; 4usize ] , pub percentAmpPu : [ f64 ; 4usize ] , pub percentInterPu : [ [ f64 ; 3usize ] ; 4usize ] , pub percentMergePu : [ [ f64 ; 3usize ] ; 4usize ] , pub percentNxN : f64 , } # [ test ] fn bindgen_test_layout_x265_pu_stats ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_pu_stats > ( ) , 296usize , concat ! ( "Size of: " , stringify ! ( x265_pu_stats ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_pu_stats > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_pu_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentSkipPu as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentSkipPu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentIntraPu as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentIntraPu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentAmpPu as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentAmpPu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentInterPu as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentInterPu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentMergePu as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentMergePu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_pu_stats > ( ) ) ) . percentNxN as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( x265_pu_stats ) , "::" , stringify ! ( percentNxN ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_analysis_2Pass { pub poc : u32 , pub frameRecordSize : u32 , pub analysisFramedata : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_x265_analysis_2Pass ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_analysis_2Pass > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( x265_analysis_2Pass ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_analysis_2Pass > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_analysis_2Pass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_2Pass > ( ) ) ) . poc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_2Pass ) , "::" , stringify ! ( poc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_2Pass > ( ) ) ) . frameRecordSize as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_2Pass ) , "::" , stringify ! ( frameRecordSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_analysis_2Pass > ( ) ) ) . analysisFramedata as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_analysis_2Pass ) , "::" , stringify ! ( analysisFramedata ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_frame_stats { pub qp : f64 , pub rateFactor : f64 , pub psnrY : f64 , pub psnrU : f64 , pub psnrV : f64 , pub psnr : f64 , pub ssim : f64 , pub decideWaitTime : f64 , pub row0WaitTime : f64 , pub wallTime : f64 , pub refWaitWallTime : f64 , pub totalCTUTime : f64 , pub stallTime : f64 , pub avgWPP : f64 , pub avgLumaDistortion : f64 , pub avgChromaDistortion : f64 , pub avgPsyEnergy : f64 , pub avgResEnergy : f64 , pub avgLumaLevel : f64 , pub bufferFill : f64 , pub bits : u64 , pub encoderOrder : :: std :: os :: raw :: c_int , pub poc : :: std :: os :: raw :: c_int , pub countRowBlocks : :: std :: os :: raw :: c_int , pub list0POC : [ :: std :: os :: raw :: c_int ; 16usize ] , pub list1POC : [ :: std :: os :: raw :: c_int ; 16usize ] , pub maxLumaLevel : u16 , pub minLumaLevel : u16 , pub maxChromaULevel : u16 , pub minChromaULevel : u16 , pub avgChromaULevel : f64 , pub maxChromaVLevel : u16 , pub minChromaVLevel : u16 , pub avgChromaVLevel : f64 , pub sliceType : :: std :: os :: raw :: c_char , pub bScenecut : :: std :: os :: raw :: c_int , pub ipCostRatio : f64 , pub frameLatency : :: std :: os :: raw :: c_int , pub cuStats : x265_cu_stats , pub puStats : x265_pu_stats , pub totalFrameTime : f64 , pub vmafFrameScore : f64 , } # [ test ] fn bindgen_test_layout_x265_frame_stats ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_frame_stats > ( ) , 944usize , concat ! ( "Size of: " , stringify ! ( x265_frame_stats ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_frame_stats > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_frame_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . qp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( qp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . rateFactor as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( rateFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . psnrY as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( psnrY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . psnrU as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( psnrU ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . psnrV as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( psnrV ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . psnr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( psnr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . ssim as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( ssim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . decideWaitTime as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( decideWaitTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . row0WaitTime as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( row0WaitTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . wallTime as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( wallTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . refWaitWallTime as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( refWaitWallTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . totalCTUTime as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( totalCTUTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . stallTime as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( stallTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgWPP as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgWPP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgLumaDistortion as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgLumaDistortion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgChromaDistortion as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgChromaDistortion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgPsyEnergy as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgPsyEnergy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgResEnergy as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgResEnergy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgLumaLevel as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgLumaLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . bufferFill as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( bufferFill ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . bits as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . encoderOrder as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( encoderOrder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . poc as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( poc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . countRowBlocks as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( countRowBlocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . list0POC as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( list0POC ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . list1POC as * const _ as usize } , 244usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( list1POC ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . maxLumaLevel as * const _ as usize } , 308usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( maxLumaLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . minLumaLevel as * const _ as usize } , 310usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( minLumaLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . maxChromaULevel as * const _ as usize } , 312usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( maxChromaULevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . minChromaULevel as * const _ as usize } , 314usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( minChromaULevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgChromaULevel as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgChromaULevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . maxChromaVLevel as * const _ as usize } , 328usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( maxChromaVLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . minChromaVLevel as * const _ as usize } , 330usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( minChromaVLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . avgChromaVLevel as * const _ as usize } , 336usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( avgChromaVLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . sliceType as * const _ as usize } , 344usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( sliceType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . bScenecut as * const _ as usize } , 348usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( bScenecut ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . ipCostRatio as * const _ as usize } , 352usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( ipCostRatio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . frameLatency as * const _ as usize } , 360usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( frameLatency ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . cuStats as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( cuStats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . puStats as * const _ as usize } , 632usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( puStats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . totalFrameTime as * const _ as usize } , 928usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( totalFrameTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_frame_stats > ( ) ) ) . vmafFrameScore as * const _ as usize } , 936usize , concat ! ( "Offset of field: " , stringify ! ( x265_frame_stats ) , "::" , stringify ! ( vmafFrameScore ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct x265_ctu_info_t { pub ctuAddress : i32 , pub ctuPartitions : [ i32 ; 64usize ] , pub ctuInfo : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_x265_ctu_info_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_ctu_info_t > ( ) , 272usize , concat ! ( "Size of: " , stringify ! ( x265_ctu_info_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_ctu_info_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_ctu_info_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_ctu_info_t > ( ) ) ) . ctuAddress as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_ctu_info_t ) , "::" , stringify ! ( ctuAddress ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_ctu_info_t > ( ) ) ) . ctuPartitions as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_ctu_info_t ) , "::" , stringify ! ( ctuPartitions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_ctu_info_t > ( ) ) ) . ctuInfo as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( x265_ctu_info_t ) , "::" , stringify ! ( ctuInfo ) ) ) ; } pub const CTUInfo_NO_CTU_INFO : CTUInfo = 0 ; pub const CTUInfo_HAS_CTU_INFO : CTUInfo = 1 ; pub const CTUInfo_CTU_INFO_CHANGE : CTUInfo = 2 ; pub type CTUInfo = u32 ; pub const MVRefineType_NO_INFO : MVRefineType = 0 ; pub const MVRefineType_AVC_INFO : MVRefineType = 1 ; pub type MVRefineType = u32 ; pub const SEIPayloadType_BUFFERING_PERIOD : SEIPayloadType = 0 ; pub const SEIPayloadType_PICTURE_TIMING : SEIPayloadType = 1 ; pub const SEIPayloadType_PAN_SCAN_RECT : SEIPayloadType = 2 ; pub const SEIPayloadType_FILLER_PAYLOAD : SEIPayloadType = 3 ; pub const SEIPayloadType_USER_DATA_REGISTERED_ITU_T_T35 : SEIPayloadType = 4 ; pub const SEIPayloadType_USER_DATA_UNREGISTERED : SEIPayloadType = 5 ; pub const SEIPayloadType_RECOVERY_POINT : SEIPayloadType = 6 ; pub const SEIPayloadType_SCENE_INFO : SEIPayloadType = 9 ; pub const SEIPayloadType_FULL_FRAME_SNAPSHOT : SEIPayloadType = 15 ; pub const SEIPayloadType_PROGRESSIVE_REFINEMENT_SEGMENT_START : SEIPayloadType = 16 ; pub const SEIPayloadType_PROGRESSIVE_REFINEMENT_SEGMENT_END : SEIPayloadType = 17 ; pub const SEIPayloadType_FILM_GRAIN_CHARACTERISTICS : SEIPayloadType = 19 ; pub const SEIPayloadType_POST_FILTER_HINT : SEIPayloadType = 22 ; pub const SEIPayloadType_TONE_MAPPING_INFO : SEIPayloadType = 23 ; pub const SEIPayloadType_FRAME_PACKING : SEIPayloadType = 45 ; pub const SEIPayloadType_DISPLAY_ORIENTATION : SEIPayloadType = 47 ; pub const SEIPayloadType_SOP_DESCRIPTION : SEIPayloadType = 128 ; pub const SEIPayloadType_ACTIVE_PARAMETER_SETS : SEIPayloadType = 129 ; pub const SEIPayloadType_DECODING_UNIT_INFO : SEIPayloadType = 130 ; pub const SEIPayloadType_TEMPORAL_LEVEL0_INDEX : SEIPayloadType = 131 ; pub const SEIPayloadType_DECODED_PICTURE_HASH : SEIPayloadType = 132 ; pub const SEIPayloadType_SCALABLE_NESTING : SEIPayloadType = 133 ; pub const SEIPayloadType_REGION_REFRESH_INFO : SEIPayloadType = 134 ; pub const SEIPayloadType_MASTERING_DISPLAY_INFO : SEIPayloadType = 137 ; pub const SEIPayloadType_CONTENT_LIGHT_LEVEL_INFO : SEIPayloadType = 144 ; pub const SEIPayloadType_ALTERNATIVE_TRANSFER_CHARACTERISTICS : SEIPayloadType = 147 ; pub type SEIPayloadType = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_sei_payload { pub payloadSize : :: std :: os :: raw :: c_int , pub payloadType : SEIPayloadType , pub payload : * mut u8 , } # [ test ] fn bindgen_test_layout_x265_sei_payload ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_sei_payload > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( x265_sei_payload ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_sei_payload > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_sei_payload ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sei_payload > ( ) ) ) . payloadSize as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_sei_payload ) , "::" , stringify ! ( payloadSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sei_payload > ( ) ) ) . payloadType as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_sei_payload ) , "::" , stringify ! ( payloadType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sei_payload > ( ) ) ) . payload as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_sei_payload ) , "::" , stringify ! ( payload ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_sei { pub numPayloads : :: std :: os :: raw :: c_int , pub payloads : * mut x265_sei_payload , } # [ test ] fn bindgen_test_layout_x265_sei ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_sei > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( x265_sei ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_sei > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_sei ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sei > ( ) ) ) . numPayloads as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_sei ) , "::" , stringify ! ( numPayloads ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sei > ( ) ) ) . payloads as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_sei ) , "::" , stringify ! ( payloads ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct x265_picture { pub pts : i64 , pub dts : i64 , pub userData : * mut :: std :: os :: raw :: c_void , pub planes : [ * mut :: std :: os :: raw :: c_void ; 3usize ] , pub stride : [ :: std :: os :: raw :: c_int ; 3usize ] , pub bitDepth : :: std :: os :: raw :: c_int , pub sliceType : :: std :: os :: raw :: c_int , pub poc : :: std :: os :: raw :: c_int , pub colorSpace : :: std :: os :: raw :: c_int , pub forceqp : :: std :: os :: raw :: c_int , pub analysisData : x265_analysis_data , pub quantOffsets : * mut f32 , pub frameData : x265_frame_stats , pub userSEI : x265_sei , pub rcData : * mut :: std :: os :: raw :: c_void , pub framesize : u64 , pub height : :: std :: os :: raw :: c_int , pub analysis2Pass : x265_analysis_2Pass , pub reorderedPts : i64 , } # [ test ] fn bindgen_test_layout_x265_picture ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_picture > ( ) , 4312usize , concat ! ( "Size of: " , stringify ! ( x265_picture ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_picture > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_picture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . pts as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . dts as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . userData as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( userData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . planes as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( planes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . stride as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( stride ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . bitDepth as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( bitDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . sliceType as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( sliceType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . poc as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( poc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . colorSpace as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( colorSpace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . forceqp as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( forceqp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . analysisData as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( analysisData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . quantOffsets as * const _ as usize } , 3296usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( quantOffsets ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . frameData as * const _ as usize } , 3304usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( frameData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . userSEI as * const _ as usize } , 4248usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( userSEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . rcData as * const _ as usize } , 4264usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( rcData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . framesize as * const _ as usize } , 4272usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( framesize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . height as * const _ as usize } , 4280usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . analysis2Pass as * const _ as usize } , 4288usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( analysis2Pass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_picture > ( ) ) ) . reorderedPts as * const _ as usize } , 4304usize , concat ! ( "Offset of field: " , stringify ! ( x265_picture ) , "::" , stringify ! ( reorderedPts ) ) ) ; } pub const X265_ME_METHODS_X265_DIA_SEARCH : X265_ME_METHODS = 0 ; pub const X265_ME_METHODS_X265_HEX_SEARCH : X265_ME_METHODS = 1 ; pub const X265_ME_METHODS_X265_UMH_SEARCH : X265_ME_METHODS = 2 ; pub const X265_ME_METHODS_X265_STAR_SEARCH : X265_ME_METHODS = 3 ; pub const X265_ME_METHODS_X265_SEA : X265_ME_METHODS = 4 ; pub const X265_ME_METHODS_X265_FULL_SEARCH : X265_ME_METHODS = 5 ; pub type X265_ME_METHODS = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_cli_csp { pub planes : :: std :: os :: raw :: c_int , pub width : [ :: std :: os :: raw :: c_int ; 3usize ] , pub height : [ :: std :: os :: raw :: c_int ; 3usize ] , } # [ test ] fn bindgen_test_layout_x265_cli_csp ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_cli_csp > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( x265_cli_csp ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_cli_csp > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( x265_cli_csp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cli_csp > ( ) ) ) . planes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_cli_csp ) , "::" , stringify ! ( planes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cli_csp > ( ) ) ) . width as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_cli_csp ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_cli_csp > ( ) ) ) . height as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_cli_csp ) , "::" , stringify ! ( height ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZL13x265_cli_csps" ] pub static mut x265_cli_csps : [ x265_cli_csp ; 6usize ] ; } pub const X265_RC_METHODS_X265_RC_ABR : X265_RC_METHODS = 0 ; pub const X265_RC_METHODS_X265_RC_CQP : X265_RC_METHODS = 1 ; pub const X265_RC_METHODS_X265_RC_CRF : X265_RC_METHODS = 2 ; pub type X265_RC_METHODS = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_sliceType_stats { pub avgQp : f64 , pub bitrate : f64 , pub psnrY : f64 , pub psnrU : f64 , pub psnrV : f64 , pub ssim : f64 , pub numPics : u32 , } # [ test ] fn bindgen_test_layout_x265_sliceType_stats ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_sliceType_stats > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( x265_sliceType_stats ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_sliceType_stats > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_sliceType_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . avgQp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( avgQp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . bitrate as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . psnrY as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( psnrY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . psnrU as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( psnrU ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . psnrV as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( psnrV ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . ssim as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( ssim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_sliceType_stats > ( ) ) ) . numPics as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_sliceType_stats ) , "::" , stringify ! ( numPics ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_stats { pub globalPsnrY : f64 , pub globalPsnrU : f64 , pub globalPsnrV : f64 , pub globalPsnr : f64 , pub globalSsim : f64 , pub elapsedEncodeTime : f64 , pub elapsedVideoTime : f64 , pub bitrate : f64 , pub aggregateVmafScore : f64 , pub accBits : u64 , pub encodedPictureCount : u32 , pub totalWPFrames : u32 , pub statsI : x265_sliceType_stats , pub statsP : x265_sliceType_stats , pub statsB : x265_sliceType_stats , pub maxCLL : u16 , pub maxFALL : u16 , } # [ test ] fn bindgen_test_layout_x265_stats ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_stats > ( ) , 264usize , concat ! ( "Size of: " , stringify ! ( x265_stats ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_stats > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . globalPsnrY as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( globalPsnrY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . globalPsnrU as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( globalPsnrU ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . globalPsnrV as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( globalPsnrV ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . globalPsnr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( globalPsnr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . globalSsim as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( globalSsim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . elapsedEncodeTime as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( elapsedEncodeTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . elapsedVideoTime as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( elapsedVideoTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . bitrate as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . aggregateVmafScore as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( aggregateVmafScore ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . accBits as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( accBits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . encodedPictureCount as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( encodedPictureCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . totalWPFrames as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( totalWPFrames ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . statsI as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( statsI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . statsP as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( statsP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . statsB as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( statsB ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . maxCLL as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( maxCLL ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_stats > ( ) ) ) . maxFALL as * const _ as usize } , 258usize , concat ! ( "Offset of field: " , stringify ! ( x265_stats ) , "::" , stringify ! ( maxFALL ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZL21x265_motion_est_names" ] pub static mut x265_motion_est_names : [ * const :: std :: os :: raw :: c_char ; 7usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL21x265_source_csp_names" ] pub static mut x265_source_csp_names : [ * const :: std :: os :: raw :: c_char ; 7usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL23x265_video_format_names" ] pub static mut x265_video_format_names : [ * const :: std :: os :: raw :: c_char ; 7usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL20x265_fullrange_names" ] pub static mut x265_fullrange_names : [ * const :: std :: os :: raw :: c_char ; 3usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL20x265_colorprim_names" ] pub static mut x265_colorprim_names : [ * const :: std :: os :: raw :: c_char ; 14usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL19x265_transfer_names" ] pub static mut x265_transfer_names : [ * const :: std :: os :: raw :: c_char ; 20usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL20x265_colmatrix_names" ] pub static mut x265_colmatrix_names : [ * const :: std :: os :: raw :: c_char ; 16usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL14x265_sar_names" ] pub static mut x265_sar_names : [ * const :: std :: os :: raw :: c_char ; 18usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL20x265_interlace_names" ] pub static mut x265_interlace_names : [ * const :: std :: os :: raw :: c_char ; 4usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL19x265_analysis_names" ] pub static mut x265_analysis_names : [ * const :: std :: os :: raw :: c_char ; 4usize ] ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_zone { pub startFrame : :: std :: os :: raw :: c_int , pub endFrame : :: std :: os :: raw :: c_int , pub bForceQp : :: std :: os :: raw :: c_int , pub qp : :: std :: os :: raw :: c_int , pub bitrateFactor : f32 , } # [ test ] fn bindgen_test_layout_x265_zone ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_zone > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( x265_zone ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_zone > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( x265_zone ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_zone > ( ) ) ) . startFrame as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_zone ) , "::" , stringify ! ( startFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_zone > ( ) ) ) . endFrame as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_zone ) , "::" , stringify ! ( endFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_zone > ( ) ) ) . bForceQp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_zone ) , "::" , stringify ! ( bForceQp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_zone > ( ) ) ) . qp as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_zone ) , "::" , stringify ! ( qp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_zone > ( ) ) ) . bitrateFactor as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_zone ) , "::" , stringify ! ( bitrateFactor ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_vmaf_data { pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub offset : usize , pub internalBitDepth : :: std :: os :: raw :: c_int , pub reference_file : * mut FILE , pub distorted_file : * mut FILE , } # [ test ] fn bindgen_test_layout_x265_vmaf_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_vmaf_data > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( x265_vmaf_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_vmaf_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_vmaf_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . width as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . height as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . offset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . internalBitDepth as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( internalBitDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . reference_file as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( reference_file ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_data > ( ) ) ) . distorted_file as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_data ) , "::" , stringify ! ( distorted_file ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_vmaf_framedata { pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub frame_set : :: std :: os :: raw :: c_int , pub internalBitDepth : :: std :: os :: raw :: c_int , pub reference_frame : * mut :: std :: os :: raw :: c_void , pub distorted_frame : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_x265_vmaf_framedata ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_vmaf_framedata > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( x265_vmaf_framedata ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_vmaf_framedata > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_vmaf_framedata ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . width as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . height as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . frame_set as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( frame_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . internalBitDepth as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( internalBitDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . reference_frame as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( reference_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_framedata > ( ) ) ) . distorted_frame as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_framedata ) , "::" , stringify ! ( distorted_frame ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_vmaf_commondata { pub format : * mut :: std :: os :: raw :: c_char , pub model_path : * mut :: std :: os :: raw :: c_char , pub log_path : * mut :: std :: os :: raw :: c_char , pub log_fmt : * mut :: std :: os :: raw :: c_char , pub disable_clip : :: std :: os :: raw :: c_int , pub disable_avx : :: std :: os :: raw :: c_int , pub enable_transform : :: std :: os :: raw :: c_int , pub phone_model : :: std :: os :: raw :: c_int , pub psnr : :: std :: os :: raw :: c_int , pub ssim : :: std :: os :: raw :: c_int , pub ms_ssim : :: std :: os :: raw :: c_int , pub pool : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_x265_vmaf_commondata ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_vmaf_commondata > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( x265_vmaf_commondata ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_vmaf_commondata > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_vmaf_commondata ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . format as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . model_path as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( model_path ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . log_path as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( log_path ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . log_fmt as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( log_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . disable_clip as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( disable_clip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . disable_avx as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( disable_avx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . enable_transform as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( enable_transform ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . phone_model as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( phone_model ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . psnr as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( psnr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . ssim as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( ssim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . ms_ssim as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( ms_ssim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_vmaf_commondata > ( ) ) ) . pool as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_vmaf_commondata ) , "::" , stringify ! ( pool ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZL3vcd" ] pub static mut vcd : [ x265_vmaf_commondata ; 1usize ] ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_param { pub cpuid : :: std :: os :: raw :: c_int , pub frameNumThreads : :: std :: os :: raw :: c_int , pub numaPools : * const :: std :: os :: raw :: c_char , pub bEnableWavefront : :: std :: os :: raw :: c_int , pub bDistributeModeAnalysis : :: std :: os :: raw :: c_int , pub bDistributeMotionEstimation : :: std :: os :: raw :: c_int , pub bLogCuStats : :: std :: os :: raw :: c_int , pub bEnablePsnr : :: std :: os :: raw :: c_int , pub bEnableSsim : :: std :: os :: raw :: c_int , pub logLevel : :: std :: os :: raw :: c_int , pub csvLogLevel : :: std :: os :: raw :: c_int , pub csvfn : * const :: std :: os :: raw :: c_char , pub internalBitDepth : :: std :: os :: raw :: c_int , pub internalCsp : :: std :: os :: raw :: c_int , pub fpsNum : u32 , pub fpsDenom : u32 , pub sourceWidth : :: std :: os :: raw :: c_int , pub sourceHeight : :: std :: os :: raw :: c_int , pub interlaceMode : :: std :: os :: raw :: c_int , pub totalFrames : :: std :: os :: raw :: c_int , pub levelIdc : :: std :: os :: raw :: c_int , pub bHighTier : :: std :: os :: raw :: c_int , pub uhdBluray : :: std :: os :: raw :: c_int , pub maxNumReferences : :: std :: os :: raw :: c_int , pub bAllowNonConformance : :: std :: os :: raw :: c_int , pub bRepeatHeaders : :: std :: os :: raw :: c_int , pub bAnnexB : :: std :: os :: raw :: c_int , pub bEnableAccessUnitDelimiters : :: std :: os :: raw :: c_int , pub bEmitHRDSEI : :: std :: os :: raw :: c_int , pub bEmitInfoSEI : :: std :: os :: raw :: c_int , pub decodedPictureHashSEI : :: std :: os :: raw :: c_int , pub bEnableTemporalSubLayers : :: std :: os :: raw :: c_int , pub bOpenGOP : :: std :: os :: raw :: c_int , pub keyframeMin : :: std :: os :: raw :: c_int , pub keyframeMax : :: std :: os :: raw :: c_int , pub bframes : :: std :: os :: raw :: c_int , pub bFrameAdaptive : :: std :: os :: raw :: c_int , pub bBPyramid : :: std :: os :: raw :: c_int , pub bFrameBias : :: std :: os :: raw :: c_int , pub lookaheadDepth : :: std :: os :: raw :: c_int , pub lookaheadSlices : :: std :: os :: raw :: c_int , pub scenecutThreshold : :: std :: os :: raw :: c_int , pub bIntraRefresh : :: std :: os :: raw :: c_int , pub maxCUSize : u32 , pub minCUSize : u32 , pub bEnableRectInter : :: std :: os :: raw :: c_int , pub bEnableAMP : :: std :: os :: raw :: c_int , pub maxTUSize : u32 , pub tuQTMaxInterDepth : u32 , pub tuQTMaxIntraDepth : u32 , pub limitTU : u32 , pub rdoqLevel : :: std :: os :: raw :: c_int , pub bEnableSignHiding : :: std :: os :: raw :: c_int , pub bEnableTransformSkip : :: std :: os :: raw :: c_int , pub noiseReductionIntra : :: std :: os :: raw :: c_int , pub noiseReductionInter : :: std :: os :: raw :: c_int , pub scalingLists : * const :: std :: os :: raw :: c_char , pub bEnableConstrainedIntra : :: std :: os :: raw :: c_int , pub bEnableStrongIntraSmoothing : :: std :: os :: raw :: c_int , pub maxNumMergeCand : u32 , pub limitReferences : u32 , pub limitModes : u32 , pub searchMethod : :: std :: os :: raw :: c_int , pub subpelRefine : :: std :: os :: raw :: c_int , pub searchRange : :: std :: os :: raw :: c_int , pub bEnableTemporalMvp : :: std :: os :: raw :: c_int , pub bEnableWeightedPred : :: std :: os :: raw :: c_int , pub bEnableWeightedBiPred : :: std :: os :: raw :: c_int , pub bSourceReferenceEstimation : :: std :: os :: raw :: c_int , pub bEnableLoopFilter : :: std :: os :: raw :: c_int , pub deblockingFilterTCOffset : :: std :: os :: raw :: c_int , pub deblockingFilterBetaOffset : :: std :: os :: raw :: c_int , pub bEnableSAO : :: std :: os :: raw :: c_int , pub bSaoNonDeblocked : :: std :: os :: raw :: c_int , pub rdLevel : :: std :: os :: raw :: c_int , pub bEnableEarlySkip : :: std :: os :: raw :: c_int , pub bEnableRecursionSkip : :: std :: os :: raw :: c_int , pub bEnableFastIntra : :: std :: os :: raw :: c_int , pub bEnableTSkipFast : :: std :: os :: raw :: c_int , pub bCULossless : :: std :: os :: raw :: c_int , pub bIntraInBFrames : :: std :: os :: raw :: c_int , pub rdPenalty : :: std :: os :: raw :: c_int , pub psyRd : f64 , pub psyRdoq : f64 , pub bEnableRdRefine : :: std :: os :: raw :: c_int , pub analysisReuseMode : :: std :: os :: raw :: c_int , pub analysisReuseFileName : * const :: std :: os :: raw :: c_char , pub bLossless : :: std :: os :: raw :: c_int , pub cbQpOffset : :: std :: os :: raw :: c_int , pub crQpOffset : :: std :: os :: raw :: c_int , pub preferredTransferCharacteristics : :: std :: os :: raw :: c_int , pub pictureStructure : :: std :: os :: raw :: c_int , pub rc : x265_param__bindgen_ty_1 , pub vui : x265_param__bindgen_ty_2 , pub masteringDisplayColorVolume : * const :: std :: os :: raw :: c_char , pub maxCLL : u16 , pub maxFALL : u16 , pub minLuma : u16 , pub maxLuma : u16 , pub log2MaxPocLsb : :: std :: os :: raw :: c_int , pub bEmitVUITimingInfo : :: std :: os :: raw :: c_int , pub bEmitVUIHRDInfo : :: std :: os :: raw :: c_int , pub maxSlices : :: std :: os :: raw :: c_uint , pub bOptQpPPS : :: std :: os :: raw :: c_int , pub bOptRefListLengthPPS : :: std :: os :: raw :: c_int , pub bMultiPassOptRPS : :: std :: os :: raw :: c_int , pub scenecutBias : f64 , pub lookaheadThreads : :: std :: os :: raw :: c_int , pub bOptCUDeltaQP : :: std :: os :: raw :: c_int , pub analysisMultiPassRefine : :: std :: os :: raw :: c_int , pub analysisMultiPassDistortion : :: std :: os :: raw :: c_int , pub bAQMotion : :: std :: os :: raw :: c_int , pub bSsimRd : :: std :: os :: raw :: c_int , pub dynamicRd : f64 , pub bEmitHDRSEI : :: std :: os :: raw :: c_int , pub bHDROpt : :: std :: os :: raw :: c_int , pub analysisReuseLevel : :: std :: os :: raw :: c_int , pub bLimitSAO : :: std :: os :: raw :: c_int , pub toneMapFile : * const :: std :: os :: raw :: c_char , pub bDhdr10opt : :: std :: os :: raw :: c_int , pub bCTUInfo : :: std :: os :: raw :: c_int , pub bUseRcStats : :: std :: os :: raw :: c_int , pub scaleFactor : :: std :: os :: raw :: c_int , pub intraRefine : :: std :: os :: raw :: c_int , pub interRefine : :: std :: os :: raw :: c_int , pub mvRefine : :: std :: os :: raw :: c_int , pub maxLog2CUSize : u32 , pub maxCUDepth : u32 , pub unitSizeDepth : u32 , pub num4x4Partitions : u32 , pub bUseAnalysisFile : :: std :: os :: raw :: c_int , pub csvfpt : * mut FILE , pub forceFlush : :: std :: os :: raw :: c_int , pub bEnableSplitRdSkip : :: std :: os :: raw :: c_int , pub bDisableLookahead : :: std :: os :: raw :: c_int , pub bLowPassDct : :: std :: os :: raw :: c_int , pub vbvBufferEnd : f64 , pub vbvEndFrameAdjust : f64 , pub bMVType : :: std :: os :: raw :: c_int , pub bCopyPicToFrame : :: std :: os :: raw :: c_int , pub gopLookahead : :: std :: os :: raw :: c_int , pub analysisSave : * const :: std :: os :: raw :: c_char , pub analysisLoad : * const :: std :: os :: raw :: c_char , pub radl : :: std :: os :: raw :: c_int , pub maxAUSizeFactor : f64 , pub bEmitIDRRecoverySEI : :: std :: os :: raw :: c_int , pub bDynamicRefine : :: std :: os :: raw :: c_int , pub bSingleSeiNal : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_param__bindgen_ty_1 { pub rateControlMode : :: std :: os :: raw :: c_int , pub qp : :: std :: os :: raw :: c_int , pub bitrate : :: std :: os :: raw :: c_int , pub qCompress : f64 , pub ipFactor : f64 , pub pbFactor : f64 , pub rfConstant : f64 , pub qpStep : :: std :: os :: raw :: c_int , pub aqMode : :: std :: os :: raw :: c_int , pub aqStrength : f64 , pub vbvMaxBitrate : :: std :: os :: raw :: c_int , pub vbvBufferSize : :: std :: os :: raw :: c_int , pub vbvBufferInit : f64 , pub cuTree : :: std :: os :: raw :: c_int , pub rfConstantMax : f64 , pub rfConstantMin : f64 , pub bStatWrite : :: std :: os :: raw :: c_int , pub bStatRead : :: std :: os :: raw :: c_int , pub statFileName : * const :: std :: os :: raw :: c_char , pub qblur : f64 , pub complexityBlur : f64 , pub bEnableSlowFirstPass : :: std :: os :: raw :: c_int , pub zoneCount : :: std :: os :: raw :: c_int , pub zones : * mut x265_zone , pub lambdaFileName : * const :: std :: os :: raw :: c_char , pub bStrictCbr : :: std :: os :: raw :: c_int , pub qgSize : u32 , pub bEnableGrain : :: std :: os :: raw :: c_int , pub qpMax : :: std :: os :: raw :: c_int , pub qpMin : :: std :: os :: raw :: c_int , pub bEnableConstVbv : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_x265_param__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_param__bindgen_ty_1 > ( ) , 184usize , concat ! ( "Size of: " , stringify ! ( x265_param__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_param__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_param__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . rateControlMode as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( rateControlMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bitrate as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qCompress as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qCompress ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . ipFactor as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( ipFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . pbFactor as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( pbFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . rfConstant as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( rfConstant ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qpStep as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qpStep ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . aqMode as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( aqMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . aqStrength as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( aqStrength ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . vbvMaxBitrate as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( vbvMaxBitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . vbvBufferSize as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( vbvBufferSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . vbvBufferInit as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( vbvBufferInit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . cuTree as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( cuTree ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . rfConstantMax as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( rfConstantMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . rfConstantMin as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( rfConstantMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bStatWrite as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bStatWrite ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bStatRead as * const _ as usize } , 108usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bStatRead ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . statFileName as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( statFileName ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qblur as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qblur ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . complexityBlur as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( complexityBlur ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bEnableSlowFirstPass as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bEnableSlowFirstPass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . zoneCount as * const _ as usize } , 140usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( zoneCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . zones as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( zones ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . lambdaFileName as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( lambdaFileName ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bStrictCbr as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bStrictCbr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qgSize as * const _ as usize } , 164usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qgSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bEnableGrain as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bEnableGrain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qpMax as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qpMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . qpMin as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( qpMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_1 > ( ) ) ) . bEnableConstVbv as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_1 ) , "::" , stringify ! ( bEnableConstVbv ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_param__bindgen_ty_2 { pub aspectRatioIdc : :: std :: os :: raw :: c_int , pub sarWidth : :: std :: os :: raw :: c_int , pub sarHeight : :: std :: os :: raw :: c_int , pub bEnableOverscanInfoPresentFlag : :: std :: os :: raw :: c_int , pub bEnableOverscanAppropriateFlag : :: std :: os :: raw :: c_int , pub bEnableVideoSignalTypePresentFlag : :: std :: os :: raw :: c_int , pub videoFormat : :: std :: os :: raw :: c_int , pub bEnableVideoFullRangeFlag : :: std :: os :: raw :: c_int , pub bEnableColorDescriptionPresentFlag : :: std :: os :: raw :: c_int , pub colorPrimaries : :: std :: os :: raw :: c_int , pub transferCharacteristics : :: std :: os :: raw :: c_int , pub matrixCoeffs : :: std :: os :: raw :: c_int , pub bEnableChromaLocInfoPresentFlag : :: std :: os :: raw :: c_int , pub chromaSampleLocTypeTopField : :: std :: os :: raw :: c_int , pub chromaSampleLocTypeBottomField : :: std :: os :: raw :: c_int , pub bEnableDefaultDisplayWindowFlag : :: std :: os :: raw :: c_int , pub defDispWinLeftOffset : :: std :: os :: raw :: c_int , pub defDispWinRightOffset : :: std :: os :: raw :: c_int , pub defDispWinTopOffset : :: std :: os :: raw :: c_int , pub defDispWinBottomOffset : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_x265_param__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_param__bindgen_ty_2 > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( x265_param__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_param__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( x265_param__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . aspectRatioIdc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( aspectRatioIdc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . sarWidth as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( sarWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . sarHeight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( sarHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableOverscanInfoPresentFlag as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableOverscanInfoPresentFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableOverscanAppropriateFlag as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableOverscanAppropriateFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableVideoSignalTypePresentFlag as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableVideoSignalTypePresentFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . videoFormat as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( videoFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableVideoFullRangeFlag as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableVideoFullRangeFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableColorDescriptionPresentFlag as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableColorDescriptionPresentFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . colorPrimaries as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( colorPrimaries ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . transferCharacteristics as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( transferCharacteristics ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . matrixCoeffs as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( matrixCoeffs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableChromaLocInfoPresentFlag as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableChromaLocInfoPresentFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . chromaSampleLocTypeTopField as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( chromaSampleLocTypeTopField ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . chromaSampleLocTypeBottomField as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( chromaSampleLocTypeBottomField ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . bEnableDefaultDisplayWindowFlag as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( bEnableDefaultDisplayWindowFlag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . defDispWinLeftOffset as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( defDispWinLeftOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . defDispWinRightOffset as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( defDispWinRightOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . defDispWinTopOffset as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( defDispWinTopOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param__bindgen_ty_2 > ( ) ) ) . defDispWinBottomOffset as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( x265_param__bindgen_ty_2 ) , "::" , stringify ! ( defDispWinBottomOffset ) ) ) ; } # [ test ] fn bindgen_test_layout_x265_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_param > ( ) , 928usize , concat ! ( "Size of: " , stringify ! ( x265_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_param > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_param ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . cpuid as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( cpuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . frameNumThreads as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( frameNumThreads ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . numaPools as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( numaPools ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableWavefront as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableWavefront ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bDistributeModeAnalysis as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bDistributeModeAnalysis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bDistributeMotionEstimation as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bDistributeMotionEstimation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bLogCuStats as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bLogCuStats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnablePsnr as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnablePsnr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableSsim as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableSsim ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . logLevel as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( logLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . csvLogLevel as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( csvLogLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . csvfn as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( csvfn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . internalBitDepth as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( internalBitDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . internalCsp as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( internalCsp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . fpsNum as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( fpsNum ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . fpsDenom as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( fpsDenom ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . sourceWidth as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( sourceWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . sourceHeight as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( sourceHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . interlaceMode as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( interlaceMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . totalFrames as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( totalFrames ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . levelIdc as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( levelIdc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bHighTier as * const _ as usize } , 92usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bHighTier ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . uhdBluray as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( uhdBluray ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxNumReferences as * const _ as usize } , 100usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxNumReferences ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bAllowNonConformance as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bAllowNonConformance ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bRepeatHeaders as * const _ as usize } , 108usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bRepeatHeaders ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bAnnexB as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bAnnexB ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableAccessUnitDelimiters as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableAccessUnitDelimiters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitHRDSEI as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitHRDSEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitInfoSEI as * const _ as usize } , 124usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitInfoSEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . decodedPictureHashSEI as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( decodedPictureHashSEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableTemporalSubLayers as * const _ as usize } , 132usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableTemporalSubLayers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bOpenGOP as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bOpenGOP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . keyframeMin as * const _ as usize } , 140usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( keyframeMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . keyframeMax as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( keyframeMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bframes as * const _ as usize } , 148usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bframes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bFrameAdaptive as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bFrameAdaptive ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bBPyramid as * const _ as usize } , 156usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bBPyramid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bFrameBias as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bFrameBias ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . lookaheadDepth as * const _ as usize } , 164usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( lookaheadDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . lookaheadSlices as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( lookaheadSlices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . scenecutThreshold as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( scenecutThreshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bIntraRefresh as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bIntraRefresh ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxCUSize as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxCUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . minCUSize as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( minCUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableRectInter as * const _ as usize } , 188usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableRectInter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableAMP as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableAMP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxTUSize as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxTUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . tuQTMaxInterDepth as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( tuQTMaxInterDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . tuQTMaxIntraDepth as * const _ as usize } , 204usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( tuQTMaxIntraDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . limitTU as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( limitTU ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . rdoqLevel as * const _ as usize } , 212usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( rdoqLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableSignHiding as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableSignHiding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableTransformSkip as * const _ as usize } , 220usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableTransformSkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . noiseReductionIntra as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( noiseReductionIntra ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . noiseReductionInter as * const _ as usize } , 228usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( noiseReductionInter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . scalingLists as * const _ as usize } , 232usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( scalingLists ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableConstrainedIntra as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableConstrainedIntra ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableStrongIntraSmoothing as * const _ as usize } , 244usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableStrongIntraSmoothing ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxNumMergeCand as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxNumMergeCand ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . limitReferences as * const _ as usize } , 252usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( limitReferences ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . limitModes as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( limitModes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . searchMethod as * const _ as usize } , 260usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( searchMethod ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . subpelRefine as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( subpelRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . searchRange as * const _ as usize } , 268usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( searchRange ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableTemporalMvp as * const _ as usize } , 272usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableTemporalMvp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableWeightedPred as * const _ as usize } , 276usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableWeightedPred ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableWeightedBiPred as * const _ as usize } , 280usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableWeightedBiPred ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bSourceReferenceEstimation as * const _ as usize } , 284usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bSourceReferenceEstimation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableLoopFilter as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableLoopFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . deblockingFilterTCOffset as * const _ as usize } , 292usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( deblockingFilterTCOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . deblockingFilterBetaOffset as * const _ as usize } , 296usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( deblockingFilterBetaOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableSAO as * const _ as usize } , 300usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableSAO ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bSaoNonDeblocked as * const _ as usize } , 304usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bSaoNonDeblocked ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . rdLevel as * const _ as usize } , 308usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( rdLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableEarlySkip as * const _ as usize } , 312usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableEarlySkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableRecursionSkip as * const _ as usize } , 316usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableRecursionSkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableFastIntra as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableFastIntra ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableTSkipFast as * const _ as usize } , 324usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableTSkipFast ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bCULossless as * const _ as usize } , 328usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bCULossless ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bIntraInBFrames as * const _ as usize } , 332usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bIntraInBFrames ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . rdPenalty as * const _ as usize } , 336usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( rdPenalty ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . psyRd as * const _ as usize } , 344usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( psyRd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . psyRdoq as * const _ as usize } , 352usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( psyRdoq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableRdRefine as * const _ as usize } , 360usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableRdRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisReuseMode as * const _ as usize } , 364usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisReuseMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisReuseFileName as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisReuseFileName ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bLossless as * const _ as usize } , 376usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bLossless ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . cbQpOffset as * const _ as usize } , 380usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( cbQpOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . crQpOffset as * const _ as usize } , 384usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( crQpOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . preferredTransferCharacteristics as * const _ as usize } , 388usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( preferredTransferCharacteristics ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . pictureStructure as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( pictureStructure ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . rc as * const _ as usize } , 400usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( rc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . vui as * const _ as usize } , 584usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( vui ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . masteringDisplayColorVolume as * const _ as usize } , 664usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( masteringDisplayColorVolume ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxCLL as * const _ as usize } , 672usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxCLL ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxFALL as * const _ as usize } , 674usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxFALL ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . minLuma as * const _ as usize } , 676usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( minLuma ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxLuma as * const _ as usize } , 678usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxLuma ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . log2MaxPocLsb as * const _ as usize } , 680usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( log2MaxPocLsb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitVUITimingInfo as * const _ as usize } , 684usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitVUITimingInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitVUIHRDInfo as * const _ as usize } , 688usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitVUIHRDInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxSlices as * const _ as usize } , 692usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxSlices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bOptQpPPS as * const _ as usize } , 696usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bOptQpPPS ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bOptRefListLengthPPS as * const _ as usize } , 700usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bOptRefListLengthPPS ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bMultiPassOptRPS as * const _ as usize } , 704usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bMultiPassOptRPS ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . scenecutBias as * const _ as usize } , 712usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( scenecutBias ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . lookaheadThreads as * const _ as usize } , 720usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( lookaheadThreads ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bOptCUDeltaQP as * const _ as usize } , 724usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bOptCUDeltaQP ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisMultiPassRefine as * const _ as usize } , 728usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisMultiPassRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisMultiPassDistortion as * const _ as usize } , 732usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisMultiPassDistortion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bAQMotion as * const _ as usize } , 736usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bAQMotion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bSsimRd as * const _ as usize } , 740usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bSsimRd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . dynamicRd as * const _ as usize } , 744usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( dynamicRd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitHDRSEI as * const _ as usize } , 752usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitHDRSEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bHDROpt as * const _ as usize } , 756usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bHDROpt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisReuseLevel as * const _ as usize } , 760usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisReuseLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bLimitSAO as * const _ as usize } , 764usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bLimitSAO ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . toneMapFile as * const _ as usize } , 768usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( toneMapFile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bDhdr10opt as * const _ as usize } , 776usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bDhdr10opt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bCTUInfo as * const _ as usize } , 780usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bCTUInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bUseRcStats as * const _ as usize } , 784usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bUseRcStats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . scaleFactor as * const _ as usize } , 788usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( scaleFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . intraRefine as * const _ as usize } , 792usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( intraRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . interRefine as * const _ as usize } , 796usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( interRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . mvRefine as * const _ as usize } , 800usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( mvRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxLog2CUSize as * const _ as usize } , 804usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxLog2CUSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxCUDepth as * const _ as usize } , 808usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxCUDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . unitSizeDepth as * const _ as usize } , 812usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( unitSizeDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . num4x4Partitions as * const _ as usize } , 816usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( num4x4Partitions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bUseAnalysisFile as * const _ as usize } , 820usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bUseAnalysisFile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . csvfpt as * const _ as usize } , 824usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( csvfpt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . forceFlush as * const _ as usize } , 832usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( forceFlush ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEnableSplitRdSkip as * const _ as usize } , 836usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEnableSplitRdSkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bDisableLookahead as * const _ as usize } , 840usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bDisableLookahead ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bLowPassDct as * const _ as usize } , 844usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bLowPassDct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . vbvBufferEnd as * const _ as usize } , 848usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( vbvBufferEnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . vbvEndFrameAdjust as * const _ as usize } , 856usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( vbvEndFrameAdjust ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bMVType as * const _ as usize } , 864usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bMVType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bCopyPicToFrame as * const _ as usize } , 868usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bCopyPicToFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . gopLookahead as * const _ as usize } , 872usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( gopLookahead ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisSave as * const _ as usize } , 880usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisSave ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . analysisLoad as * const _ as usize } , 888usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( analysisLoad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . radl as * const _ as usize } , 896usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( radl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . maxAUSizeFactor as * const _ as usize } , 904usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( maxAUSizeFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bEmitIDRRecoverySEI as * const _ as usize } , 912usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bEmitIDRRecoverySEI ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bDynamicRefine as * const _ as usize } , 916usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bDynamicRefine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_param > ( ) ) ) . bSingleSeiNal as * const _ as usize } , 920usize , concat ! ( "Offset of field: " , stringify ! ( x265_param ) , "::" , stringify ! ( bSingleSeiNal ) ) ) ; } extern "C" { pub fn x265_param_alloc ( ) -> * mut x265_param ; } extern "C" { pub fn x265_param_free ( arg1 : * mut x265_param ) ; } extern "C" { pub fn x265_param_default ( param : * mut x265_param ) ; } extern "C" { pub fn x265_param_parse ( p : * mut x265_param , name : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_ZL18x265_profile_names" ] pub static mut x265_profile_names : [ * const :: std :: os :: raw :: c_char ; 22usize ] ; } extern "C" { pub fn x265_param_apply_profile ( arg1 : * mut x265_param , profile : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_ZL17x265_preset_names" ] pub static mut x265_preset_names : [ * const :: std :: os :: raw :: c_char ; 11usize ] ; } extern "C" { # [ link_name = "\u{1}_ZL15x265_tune_names" ] pub static mut x265_tune_names : [ * const :: std :: os :: raw :: c_char ; 6usize ] ; } extern "C" { pub fn x265_param_default_preset ( arg1 : * mut x265_param , preset : * const :: std :: os :: raw :: c_char , tune : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_picture_alloc ( ) -> * mut x265_picture ; } extern "C" { pub fn x265_picture_free ( arg1 : * mut x265_picture ) ; } extern "C" { pub fn x265_picture_init ( param : * mut x265_param , pic : * mut x265_picture ) ; } extern "C" { # [ link_name = "\u{1}x265_max_bit_depth" ] pub static mut x265_max_bit_depth : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}x265_version_str" ] pub static mut x265_version_str : * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}x265_build_info_str" ] pub static mut x265_build_info_str : * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn x265_encoder_open_160 ( arg1 : * mut x265_param ) -> * mut x265_encoder ; } extern "C" { pub fn x265_encoder_parameters ( arg1 : * mut x265_encoder , arg2 : * mut x265_param ) ; } extern "C" { pub fn x265_encoder_headers ( arg1 : * mut x265_encoder , pp_nal : * mut * mut x265_nal , pi_nal : * mut u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_encoder_encode ( encoder : * mut x265_encoder , pp_nal : * mut * mut x265_nal , pi_nal : * mut u32 , pic_in : * mut x265_picture , pic_out : * mut x265_picture ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_encoder_reconfig ( arg1 : * mut x265_encoder , arg2 : * mut x265_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_encoder_get_stats ( encoder : * mut x265_encoder , arg1 : * mut x265_stats , statsSizeBytes : u32 ) ; } extern "C" { pub fn x265_encoder_log ( encoder : * mut x265_encoder , argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn x265_encoder_close ( arg1 : * mut x265_encoder ) ; } extern "C" { pub fn x265_encoder_intra_refresh ( arg1 : * mut x265_encoder ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_encoder_ctu_info ( arg1 : * mut x265_encoder , poc : :: std :: os :: raw :: c_int , ctu : * mut * mut x265_ctu_info_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_get_slicetype_poc_and_scenecut ( encoder : * mut x265_encoder , slicetype : * mut :: std :: os :: raw :: c_int , poc : * mut :: std :: os :: raw :: c_int , sceneCut : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_get_ref_frame_list ( encoder : * mut x265_encoder , arg1 : * mut * mut x265_picyuv , arg2 : * mut * mut x265_picyuv , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int , arg5 : * mut :: std :: os :: raw :: c_int , arg6 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_set_analysis_data ( encoder : * mut x265_encoder , analysis_data : * mut x265_analysis_data , poc : :: std :: os :: raw :: c_int , cuBytes : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn x265_cleanup ( ) ; } extern "C" { pub fn x265_csvlog_open ( arg1 : * const x265_param ) -> * mut FILE ; } extern "C" { pub fn x265_csvlog_frame ( arg1 : * const x265_param , arg2 : * const x265_picture ) ; } extern "C" { pub fn x265_csvlog_encode ( arg1 : * const x265_param , arg2 : * const x265_stats , padx : :: std :: os :: raw :: c_int , pady : :: std :: os :: raw :: c_int , argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn x265_dither_image ( arg1 : * mut x265_picture , picWidth : :: std :: os :: raw :: c_int , picHeight : :: std :: os :: raw :: c_int , errorBuf : * mut i16 , bitDepth : :: std :: os :: raw :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct x265_api { pub api_major_version : :: std :: os :: raw :: c_int , pub api_build_number : :: std :: os :: raw :: c_int , pub sizeof_param : :: std :: os :: raw :: c_int , pub sizeof_picture : :: std :: os :: raw :: c_int , pub sizeof_analysis_data : :: std :: os :: raw :: c_int , pub sizeof_zone : :: std :: os :: raw :: c_int , pub sizeof_stats : :: std :: os :: raw :: c_int , pub bit_depth : :: std :: os :: raw :: c_int , pub version_str : * const :: std :: os :: raw :: c_char , pub build_info_str : * const :: std :: os :: raw :: c_char , pub param_alloc : :: std :: option :: Option < unsafe extern "C" fn ( ) -> * mut x265_param > , pub param_free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param ) > , pub param_default : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param ) > , pub param_parse : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int > , pub param_apply_profile : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param , arg2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int > , pub param_default_preset : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int > , pub picture_alloc : :: std :: option :: Option < unsafe extern "C" fn ( ) -> * mut x265_picture > , pub picture_free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_picture ) > , pub picture_init : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param , arg2 : * mut x265_picture ) > , pub encoder_open : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_param ) -> * mut x265_encoder > , pub encoder_parameters : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut x265_param ) > , pub encoder_reconfig : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut x265_param ) -> :: std :: os :: raw :: c_int > , pub encoder_headers : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut * mut x265_nal , arg3 : * mut u32 ) -> :: std :: os :: raw :: c_int > , pub encoder_encode : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut * mut x265_nal , arg3 : * mut u32 , arg4 : * mut x265_picture , arg5 : * mut x265_picture ) -> :: std :: os :: raw :: c_int > , pub encoder_get_stats : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut x265_stats , arg3 : u32 ) > , pub encoder_log : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut * mut :: std :: os :: raw :: c_char ) > , pub encoder_close : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder ) > , pub cleanup : :: std :: option :: Option < unsafe extern "C" fn ( ) > , pub sizeof_frame_stats : :: std :: os :: raw :: c_int , pub encoder_intra_refresh : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder ) -> :: std :: os :: raw :: c_int > , pub encoder_ctu_info : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut * mut x265_ctu_info_t ) -> :: std :: os :: raw :: c_int > , pub get_slicetype_poc_and_scenecut : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut :: std :: os :: raw :: c_int , arg3 : * mut :: std :: os :: raw :: c_int , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub get_ref_frame_list : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_encoder , arg2 : * mut * mut x265_picyuv , arg3 : * mut * mut x265_picyuv , arg4 : :: std :: os :: raw :: c_int , arg5 : :: std :: os :: raw :: c_int , arg6 : * mut :: std :: os :: raw :: c_int , arg7 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub csvlog_open : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const x265_param ) -> * mut FILE > , pub csvlog_frame : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const x265_param , arg2 : * const x265_picture ) > , pub csvlog_encode : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const x265_param , arg2 : * const x265_stats , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int , arg5 : :: std :: os :: raw :: c_int , arg6 : * mut * mut :: std :: os :: raw :: c_char ) > , pub dither_image : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut x265_picture , arg2 : :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int , arg4 : * mut i16 , arg5 : :: std :: os :: raw :: c_int ) > , pub set_analysis_data : :: std :: option :: Option < unsafe extern "C" fn ( encoder : * mut x265_encoder , analysis_data : * mut x265_analysis_data , poc : :: std :: os :: raw :: c_int , cuBytes : u32 ) -> :: std :: os :: raw :: c_int > , } # [ test ] fn bindgen_test_layout_x265_api ( ) { assert_eq ! ( :: std :: mem :: size_of :: < x265_api > ( ) , 272usize , concat ! ( "Size of: " , stringify ! ( x265_api ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < x265_api > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( x265_api ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . api_major_version as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( api_major_version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . api_build_number as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( api_build_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_param as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_param ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_picture as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_picture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_analysis_data as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_analysis_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_zone as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_zone ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_stats as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . bit_depth as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( bit_depth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . version_str as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( version_str ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . build_info_str as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( build_info_str ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_alloc as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_alloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_free as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_free ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_default as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_default ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_parse as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_parse ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_apply_profile as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_apply_profile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . param_default_preset as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( param_default_preset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . picture_alloc as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( picture_alloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . picture_free as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( picture_free ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . picture_init as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( picture_init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_open as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_open ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_parameters as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_parameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_reconfig as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_reconfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_headers as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_headers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_encode as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_encode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_get_stats as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_get_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_log as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_log ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_close as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_close ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . cleanup as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( cleanup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . sizeof_frame_stats as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( sizeof_frame_stats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_intra_refresh as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_intra_refresh ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . encoder_ctu_info as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( encoder_ctu_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . get_slicetype_poc_and_scenecut as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( get_slicetype_poc_and_scenecut ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . get_ref_frame_list as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( get_ref_frame_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . csvlog_open as * const _ as usize } , 232usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( csvlog_open ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . csvlog_frame as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( csvlog_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . csvlog_encode as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( csvlog_encode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . dither_image as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( dither_image ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < x265_api > ( ) ) ) . set_analysis_data as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( x265_api ) , "::" , stringify ! ( set_analysis_data ) ) ) ; } extern "C" { pub fn x265_api_get_160 ( bitDepth : :: std :: os :: raw :: c_int ) -> * const x265_api ; } extern "C" { pub fn x265_api_query ( bitDepth : :: std :: os :: raw :: c_int , apiVersion : :: std :: os :: raw :: c_int , err : * mut :: std :: os :: raw :: c_int ) -> * const x265_api ; } extern "C" { # [ link_name = "\u{1}_ZL23x265_api_query_errnames" ] pub static mut x265_api_query_errnames : [ * const :: std :: os :: raw :: c_char ; 5usize ] ; } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; }
     |                                                     
